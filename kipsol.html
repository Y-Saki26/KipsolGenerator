<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Kipsol Generator</title>
</head>
<body>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script type="text/javascript" src="./kipsol_script.js"></script>
    <H1>Kipsol Generator</H1>
    <div>
        <p>legends:</p>
        <canvas id="canvasExample" width="800" height="300" style="border:1px solid;"></canvas>
    </div>
    <div>
        <p>
            <details>
                <summary>設定</summary>
                <ul>
                    <li>
                        字母<br>
                        <ul>
                            <li><label>有声音円のサイズ: <input type="text" id="inputVoisedSize" name="inputVoisedSize" maxlength="10" size="4" value="50"/></label></li>
                            <li><label>無声音円のサイズ: <input type="text" id="inputVoiselessSize" name="inputVoiselessSize" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>語末記号のサイズ: <input type="text" id="inputEOWSize" name="inputEOWSize" maxlength="10" size="4" value="7"/></label></li>
                            <li><label>中心の点のサイズ: <input type="text" id="inputPivotSize" name="inputPivotSize" maxlength="10" size="4" value="3"/></label></li>
                            <li><label>連続子音の離す距離: <input type="text" id="inputPaddingLength" name="inputPaddingLength" maxlength="10" size="4" value="10"/></label></li>
                        </ul>
                    </li>
                    <li>
                        余白<br>
                        <ul>
                            <li><label>全部: <input type="text" id="inputMarginAll" name="inputMarginAll" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>上: <input type="text" id="inputMarginTop" name="inputMarginTop" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>下: <input type="text" id="inputMarginBottom" name="inputMarginBottom" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>左: <input type="text" id="inputMarginLeft" name="inputMarginLeft" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>右: <input type="text" id="inputMarginRight" name="inputMarginRight" maxlength="10" size="4" value="25"/></label></li>
                        </ul>
                    </li>
                    <li>
                        アニメーション<br>
                        <ul>
                            <li><label>速度: <input type="text" id="inputRotationSpeed" name="inputRotationSpeed" maxlength="10" size="4" value="1"/></label></li>
                            <li><label>span: <input type="text" id="inputAnimationSpan" name="inputAnimationSpan" maxlength="10" size="4" value="1"/> sec</label></li>
                        </ul>
                    </li>
                </ul>
            </details>
        </p>
    </div>
    <div>
        <p>input words below:</p>
        <input type="text" id="inputText" name="inputText" maxlength="100" size="80" value="kipsol"/>
        <canvas id="canvas" width="800" height="500" style="border:1px solid;"></canvas>
    </div>
    <div>
        <p>
            <button type="button" onclick="downloadAsJSON()">Export JSON</button>
            <button type="button" onclick="downloadAsSVG()">Export SVG</button>
        </p>
    </div>
    <script  type="text/javascript">
/*
fabric.Canvas.prototype.strokeLine = function(startX, startY, endX, endY, strokeWidth=1, strokeColor="black", angle=0){
    const line = new fabric.Line([startX, startY, endX, endY], {
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        angle: angle
    });
    this.add(line);
    return line;
};
fabric.Canvas.prototype.strokeCircle = function(centerX, centerY, radius, strokeWidth=1, strokeColor="black", angle=0){
    const circle = new fabric.Circle({
        left: centerX - radius,
        top: centerY - radius,
        radius: radius,
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        fill: null,
        angle: angle
    });
    this.add(circle);
    return circle;
};
fabric.Canvas.prototype.fillCircle = function(centerX, centerY, radius, strokeWidth=1, strokeColor="black", fillColor="black", angle=0){
    const circle = new fabric.Circle({
        left: centerX - radius,
        top: centerY - radius,
        radius: radius,
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        fill: fillColor,
        angle: angle
    });
    this.add(circle);
    return circle;
};
fabric.Canvas.prototype.kipsol = {
    consonantPadding: undefined,
    radiusPivot: undefined,
    radiusVoiced: undefined,
    radiusVoiceless: undefined,
    radiusEOW: undefined
}
fabric.Canvas.prototype.drawZ = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiced));
    elems.push(this.fillCircle(centerX, centerY, this.kipsol.radiusPivot));
    return elems;
};
fabric.Canvas.prototype.drawD = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 120, 240].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawG = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 90, 180, 270].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawB = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 60, 120, 180, 240, 300].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawS = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    elems.push(this.fillCircle(centerX, centerY, this.kipsol.radiusPivot));
    return elems;
};
fabric.Canvas.prototype.drawT = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 120, 240].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawK = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 90, 180, 270].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawP = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 60, 120, 180, 240, 300].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawL = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    return elems;
};
fabric.Canvas.prototype.drawN = function(centerX, centerY){
    let elems = this.drawD(centerX, centerY);
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    return elems;
};
fabric.Canvas.prototype.drawEOW = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusEOW));
    return elems;
};
*/

///////////////////////////////////////////////////////////////////////////////
/** TODO
 * protptypeを書き換えるよりclassを作る
 * [v] 最初の要素の描画でlineが入ることがある(cf. subulok)．最初を分けて処理したほうが良い 
 * [v] 先にオブジェクトの相対位置の計算を済ませてからリストを参照して描画したほうが良さそう
 * [v] 語末文字に線が侵入する問題
 * 文章組版の実装
 * 部位サイズ，キャンバスサイズ変更機能の実装
 * 数字，ピリオドの実装
 * 歯車モチーフなので回したい
 */
///////////////////////////////////////////////////////////////////////////////

/*
function drawText(canvas, str, startX=0, startY=0){
    const func_map = {
        'Z': (x,y) => canvas.drawZ(x, y),
        'D': (x,y) => canvas.drawD(x, y),
        'G': (x,y) => canvas.drawG(x, y),
        'B': (x,y) => canvas.drawB(x, y),
        'L': (x,y) => canvas.drawL(x, y),
        'N': (x,y) => canvas.drawN(x, y),
        'S': (x,y) => canvas.drawS(x, y),
        'T': (x,y) => canvas.drawT(x, y),
        'K': (x,y) => canvas.drawK(x, y),
        'P': (x,y) => canvas.drawP(x, y),
    }
    let cur = {
        X: startX,
        Y: startY
    };
    let preR = null, preD = 0, preV = null;
    let elems = [];
    Array.from(str).forEach((s)=>{
        s = s.toUpperCase();
        if("IOU".includes(s)){
            // vowel
            if(preV==null){
                console.log("Error: unexpected input (initial vowel)");
            }
            preV = true;
            if(s==='I'){
                preD = -45;
            }else if(s==='O'){
                preD = 0;
            }else if(s==='U'){
                preD = 45;
            }else{
                console.log("Unexpected error");
            }
        }else if("ZDGBLNSTKP".includes(s)){
            // consonant
            const nextR = ("STKP".includes(s))? canvas.kipsol.radiusVoiceless: canvas.kipsol.radiusVoiced;
            const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
            const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
            const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
            elems = elems.concat(func_map[s](nextX, nextY));
            if(!preV){
                elems.push(canvas.strokeLine(cur.X, cur.Y, nextX, nextY));
            }
            preR = nextR;
            preD = 0;
            preV = false;
            cur.X = nextX;
            cur.Y = nextY;
        }else{
            console.log("Error: unexpected input", s);
        }
    });
    // end of word
    const nextR = canvas.kipsol.radiusEOW;
    const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
    const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
    const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
    if(!preV){
        elems.push(canvas.strokeLine(cur.X, cur.Y, nextX, nextY));
    }
    elems = elems.concat(canvas.drawEOW(nextX, nextY));
    return elems
}
*/

/*
function drawTextbox(canvas, text, x, y, fontSize=20, width=null){
    const textbox = new fabric.Textbox(text, {
        top: y,
        left: x,
        fontSize: fontSize,
        width: width
    });
    canvas.add(textbox);
    return textbox;
}
*/

/*
function drawExample(){
    const canvas0 = new fabric.Canvas('canvasExample');
    canvas0.kipsol = {
        consonantPadding: 10,
        radiusPivot: 3,
        radiusVoiced: 40,
        radiusVoiceless: 20,
        radiusEOW: 7
    }

    var textWidth = canvas0.kipsol.radiusVoiced*0.2;
    var x = textWidth*2;

    canvas0.setWidth(textWidth*18+canvas0.kipsol.radiusVoiced*12);
    canvas0.setHeight(textWidth*6+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless*2);

    drawTextbox(canvas0, "z", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "s", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    canvas0.drawZ(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    canvas0.drawS(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;

    drawTextbox(canvas0, "d", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "t", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    canvas0.drawD(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    canvas0.drawT(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;

    drawTextbox(canvas0, "g", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "k", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    canvas0.drawG(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    canvas0.drawK(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;

    drawTextbox(canvas0, "b", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "p", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    canvas0.drawB(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    canvas0.drawP(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;

    drawTextbox(canvas0, "l", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "end of word", x, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*15);
    x += textWidth;
    canvas0.drawL(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    canvas0.drawEOW(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;

    drawTextbox(canvas0, "n", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
    drawTextbox(canvas0, "end of centence", x, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*15);
    x += textWidth;
    canvas0.drawN(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
    x += canvas0.kipsol.radiusVoiced*2 + textWidth;
}
*/


const inputElement = document.getElementById('inputText');
let kipsol_settings = {
    consonantPadding: 10,
    radiusPivot: 3,
    radiusVoiced: 50,
    radiusVoiceless: 25,
    radiusEOW: 7,
    voweldir: {
        "I": -45,
        "O": 0,
        "U": 45
    }
};
let mergin = {
    top: 25,
    bottom: 25,
    left: 25,
    right: 25
};
let animationSpeed = 0;//0.2 * 1000;
let rotateSpeed = 3 * animationSpeed / 1000;

function drawExample2(){
    let kc = new KipsolCanvas('canvasExample', kipsol_settings);

    let textWidth = kipsol_settings.radiusVoiced*0.2;
    let x = textWidth*2;

    kc.canvas.setWidth(textWidth*18+kipsol_settings.radiusVoiced*12);
    kc.canvas.setHeight(textWidth*6+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless*2);

    kc.strokeTextbox("z", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("s", x+kipsol_settings.radiusVoiced-kipsol_settings.radiusVoiceless-textWidth, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    kc.strokeZ(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    kc.strokeS(x + kipsol_settings.radiusVoiced, textWidth*4+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless);
    x += kipsol_settings.radiusVoiced*2 + textWidth;

    kc.strokeTextbox("d", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("t", x+kipsol_settings.radiusVoiced-kipsol_settings.radiusVoiceless-textWidth, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    kc.strokeD(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    kc.strokeT(x + kipsol_settings.radiusVoiced, textWidth*4+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless);
    x += kipsol_settings.radiusVoiced*2 + textWidth;

    kc.strokeTextbox("g", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("k", x+kipsol_settings.radiusVoiced-kipsol_settings.radiusVoiceless-textWidth, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    kc.strokeG(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    kc.strokeK(x + kipsol_settings.radiusVoiced, textWidth*4+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless);
    x += kipsol_settings.radiusVoiced*2 + textWidth;

    kc.strokeTextbox("b", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("p", x+kipsol_settings.radiusVoiced-kipsol_settings.radiusVoiceless-textWidth, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    x += textWidth;
    kc.strokeB(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    kc.strokeP(x + kipsol_settings.radiusVoiced, textWidth*4+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless);
    x += kipsol_settings.radiusVoiced*2 + textWidth;

    kc.strokeTextbox("l", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("end of word", x, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*15);
    x += textWidth;
    kc.strokeL(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    kc.strokeEOW(x + kipsol_settings.radiusVoiced, textWidth*4+kipsol_settings.radiusVoiced*2+kipsol_settings.radiusVoiceless);
    x += kipsol_settings.radiusVoiced*2 + textWidth;

    kc.strokeTextbox("n", x, textWidth, kipsol_settings.radiusVoiced*0.4, textWidth*2);
    kc.strokeTextbox("end of centence", x, textWidth*3+kipsol_settings.radiusVoiced*2, kipsol_settings.radiusVoiced*0.4, textWidth*15);
    x += textWidth;
    kc.strokeN(x + kipsol_settings.radiusVoiced, textWidth*2+kipsol_settings.radiusVoiced);
    x += kipsol_settings.radiusVoiced*2 + textWidth;
}

drawExample2();

const kCanvas = new KipsolCanvas('canvas', kipsol_settings);
kCanvas.canvas.setWidth(800);
kCanvas.canvas.setHeight(500);
let rotate = 0;

function drawInputText(){
    kCanvas.canvas.remove(...kCanvas.canvas.getObjects())
    let inputText = inputElement.value;
    let cil = calcItemList(kipsol_settings, inputText);
    console.log(cil.area, cil.items);
    kCanvas.canvas.setWidth(mergin.left + mergin.right + cil.area.maxX - cil.area.minX);
    kCanvas.canvas.setHeight(mergin.top + mergin.bottom + cil.area.maxY - cil.area.minY);
    kCanvas.drawItems(cil.items, {X: mergin.left-cil.area.minX, Y: mergin.top-cil.area.minY, R: rotate});
    rotate += rotateSpeed;
    rotate %= 360;
}

drawInputText();

if(animationSpeed>0)
    setInterval(drawInputText, animationSpeed);
else
    inputElement.addEventListener("change", drawInputText);

function downloadAsSVG(){
    downloadText(`${inputElement.value}.svg`, kCanvas.canvas.toSVG());
}
function downloadAsJSON(){
    downloadText(`${inputElement.value}.json`, JSON.stringify(kCanvas.canvas));
}
</script>
</body>
</html>