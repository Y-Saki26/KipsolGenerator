<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Kipsol Generator</title>
</head>
<body>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <H1>Kipsol Generator</H1>
    <div>
        <p>legends:</p>
        <canvas id="canvasExample" width="800" height="300" style="border:1px solid;"></canvas>
    </div>
    <div>
        <p>
            <details>
                <summary>設定</summary>
                <ul>
                    <li>
                        字母<br>
                        <ul>
                            <li><label>有声音円のサイズ: <input type="text" id="inputVoisedSize" name="inputVoisedSize" maxlength="10" size="4" value="50"/></label></li>
                            <li><label>無声音円のサイズ: <input type="text" id="inputVoiselessSize" name="inputVoiselessSize" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>語末記号のサイズ: <input type="text" id="inputEOWSize" name="inputEOWSize" maxlength="10" size="4" value="7"/></label></li>
                            <li><label>中心の点のサイズ: <input type="text" id="inputPivotSize" name="inputPivotSize" maxlength="10" size="4" value="3"/></label></li>
                            <li><label>連続子音の離す距離: <input type="text" id="inputPaddingLength" name="inputPaddingLength" maxlength="10" size="4" value="10"/></label></li>
                        </ul>
                    </li>
                    <li>
                        余白<br>
                        <ul>
                            <li><label>全部: <input type="text" id="inputMarginAll" name="inputMarginAll" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>上: <input type="text" id="inputMarginTop" name="inputMarginTop" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>下: <input type="text" id="inputMarginBottom" name="inputMarginBottom" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>左: <input type="text" id="inputMarginLeft" name="inputMarginLeft" maxlength="10" size="4" value="25"/></label></li>
                            <li><label>右: <input type="text" id="inputMarginRight" name="inputMarginRight" maxlength="10" size="4" value="25"/></label></li>
                        </ul>
                    </li>
                </ul>
            </details>
        </p>
    </div>
    <div>
        <p>input words below:</p>
        <input type="text" id="inputText" name="inputText" maxlength="100" size="80" value="kipsol"/>
        <canvas id="canvas" width="800" height="500" style="border:1px solid;"></canvas>
    </div>
    <div>
        <p>
            <button type="button" onclick="downloadAsJSON()">Export JSON</button>
            <button type="button" onclick="downloadAsSVG()">Export SVG</button>
        </p>
    </div>
    <script  type="text/javascript">

fabric.Canvas.prototype.strokeLine = function(startX, startY, endX, endY, strokeWidth=1, strokeColor="black", angle=0){
    const line = new fabric.Line([startX, startY, endX, endY], {
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        angle: angle
    });
    this.add(line);
    return line;
};
fabric.Canvas.prototype.strokeCircle = function(centerX, centerY, radius, strokeWidth=1, strokeColor="black", angle=0){
    const circle = new fabric.Circle({
        left: centerX - radius,
        top: centerY - radius,
        radius: radius,
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        fill: null,
        angle: angle
    });
    this.add(circle);
    return circle;
};
fabric.Canvas.prototype.fillCircle = function(centerX, centerY, radius, strokeWidth=1, strokeColor="black", fillColor="black", angle=0){
    const circle = new fabric.Circle({
        left: centerX - radius,
        top: centerY - radius,
        radius: radius,
        strokeWidth: strokeWidth,
        stroke: strokeColor,
        fill: fillColor,
        angle: angle
    });
    this.add(circle);
    return circle;
};
fabric.Canvas.prototype.kipsol = {
    consonantPadding: undefined,
    radiusPivot: undefined,
    radiusVoiced: undefined,
    radiusVoiceless: undefined,
    radiusEOW: undefined
}
fabric.Canvas.prototype.drawZ = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiced));
    elems.push(this.fillCircle(centerX, centerY, this.kipsol.radiusPivot));
    return elems;
};
fabric.Canvas.prototype.drawD = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 120, 240].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawG = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 90, 180, 270].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawB = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    const radius = this.kipsol.radiusVoiced;
    [0, 60, 120, 180, 240, 300].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawS = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    elems.push(this.fillCircle(centerX, centerY, this.kipsol.radiusPivot));
    return elems;
};
fabric.Canvas.prototype.drawT = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 120, 240].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawK = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 90, 180, 270].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawP = function(centerX, centerY){
    let elems = this.drawS(centerX, centerY);
    const radius = this.kipsol.radiusVoiceless;
    [0, 60, 120, 180, 240, 300].forEach((deg)=>{
        rad=(-90-deg)/180*Math.PI;
        elems.push(this.strokeLine(centerX, centerY, centerX+radius*Math.cos(rad), centerY+radius*Math.sin(rad)));
    });
    return elems;
};
fabric.Canvas.prototype.drawL = function(centerX, centerY){
    let elems = this.drawZ(centerX, centerY);
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    return elems;
};
fabric.Canvas.prototype.drawN = function(centerX, centerY){
    let elems = this.drawD(centerX, centerY);
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusVoiceless));
    return elems;
};
fabric.Canvas.prototype.drawEOW = function(centerX, centerY){
    let elems = [];
    elems.push(this.strokeCircle(centerX, centerY, this.kipsol.radiusEOW));
    return elems;
};

///////////////////////////////////////////////////////////////////////////////
/** TODO
 * protptypeを書き換えるよりclassを作る
 * [v] 最初の要素の描画でlineが入ることがある(cf. subulok)．最初を分けて処理したほうが良い 
 * [v] 先にオブジェクトの相対位置の計算を済ませてからリストを参照して描画したほうが良さそう
 * [v] 語末文字に線が侵入する問題
 * 文章組版の実装
 * 部位サイズ，キャンバスサイズ変更機能の実装
 * 数字，ピリオドの実装
 * 歯車モチーフなので回したい
 */
///////////////////////////////////////////////////////////////////////////////

function calcItemList(canvas, str, startX=0, startY=0){
    let cur = {
        X: startX,
        Y: startY,
        radius: 0,
        direction: 0
    };
    let area = {
        minX: 0,
        maxX: 0,
        minY: 0,
        maxY: 0,
        append: function(x, y, r){
            this.minX = Math.min(this.minX, x-r);
            this.maxX = Math.max(this.maxX, x+r);
            this.minY = Math.min(this.minY, y-r);
            this.maxY = Math.max(this.maxY, y+r);
            //console.log("append:", x, y, r, this);
        }
    };
    let items = [];
    //console.log(area, items);
    Array.from(str).forEach((s)=>{
        s = s.toUpperCase();
        if("IOU".includes(s)){
            // vowel
            if(items.length===0){
                console.log("Error: unexpected input (initial vowel)");
                errState = -1;
                return errState;
            }
            if(items.slice(-1)[0].type==="vowel"){
                console.log("Error: unexpected input (continuous vowel)", s);
                errState = -1;
                return errState;
            }
            cur.direction = canvas.kipsol.voweldir[s];
            if(cur.direction==undefined){
                console.log("Unexpected error", s);
                errState = -1;
                return errState;
            }
            items.push({
                type: "vowel",
                str: s,
                dir: cur.direction
            });
        }else if("ZDGBLNSTKP".includes(s)){
            // consonant
            const nextR = ("STKP".includes(s))? canvas.kipsol.radiusVoiceless: canvas.kipsol.radiusVoiced;
            let dist, nextX, nextY;
            if(items.length===0){
                dist = 0;
                nextX = cur.X;
                nextY = cur.Y;
            }else{
                dist = cur.radius + nextR;
                if(items.slice(-1)[0].type==="consonant"){
                    dist += canvas.kipsol.consonantPadding;
                }
                nextX = cur.X + dist * Math.cos(cur.direction / 180 * Math.PI);
                nextY = cur.Y + dist * Math.sin(cur.direction / 180 * Math.PI);
            }
            if(items.length>0 && items.slice(-1)[0].type==="consonant"){
                items.push({
                    type: "line",
                    startX: cur.X,
                    startY: cur.Y,
                    endX: nextX,
                    endY: nextY
                });
            }
            items.push({
                type: "consonant",
                str: s,
                centerX: nextX,
                centerY: nextY,
                radius: nextR
            });
            area.append(nextX, nextY, nextR);
            cur.X = nextX;
            cur.Y = nextY;
            cur.radius = nextR;
            cur.direction = canvas.kipsol.voweldir["O"];
        }else{
            console.log("Error: unexpected input", s);
            errState = -1;
            return errState;
        }
        //console.log(area, items.slice(-1)[0]);
    });
    {
        // end of word
        const nextR = canvas.kipsol.radiusEOW;
        let dist, nextX, nextY;
        if(items.length===0){
            dist = 0;
            nextX = cur.X;
            nextY = cur.Y;
            console.log("Warning: blank word");
            errState = -1;
        }else{
            dist = cur.radius + nextR;
            if(items.slice(-1)[0].type==="consonant"){
                dist += canvas.kipsol.consonantPadding;
            }
            nextX = cur.X + dist * Math.cos(cur.direction / 180 * Math.PI);
            nextY = cur.Y + dist * Math.sin(cur.direction / 180 * Math.PI);
        }
        if(items.length>0 && items.slice(-1)[0].type==="consonant"){
            _nxtX = cur.X + (dist - nextR) * Math.cos(cur.direction / 180 * Math.PI);
            _nxtY = cur.Y + (dist - nextR) * Math.sin(cur.direction / 180 * Math.PI);
            items.push({
                type: "line",
                startX: cur.X,
                startY: cur.Y,
                endX: _nxtX,
                endY: _nxtY
            });
        }
        items.push({
            type: "EOW",
            centerX: nextX,
            centerY: nextY,
            radius: nextR
        });
        area.append(nextX, nextY, nextR);
        //console.log(area, items.slice(-1)[0]);
    }
    return {
        items: items,
        area: area
    };
}

function calcTextArea(canvas, str, startX=0, startY=0){
    let cur = {
        X: startX,
        Y: startY
    };
    let area = {
        minX: 0,
        maxX: 0,
        minY: 0,
        maxY: 0,
        append: function(x, y, r){
            this.minX = Math.min(this.minX, x-r);
            this.maxX = Math.max(this.maxX, x+r);
            this.minY = Math.min(this.minY, y-r);
            this.maxY = Math.max(this.maxY, y+r);
            //console.log("append:", x, y, r, this);
        }
    };
    let items = [];
    let preR = null, preD = 0, preV = null;
    let errState = 0;
    Array.from(str).forEach((s)=>{
        s = s.toUpperCase();
        if("IOU".includes(s)){
            // vowel
            if(preV==null){
                console.log("Error: unexpected input (initial vowel)");
                errState = -1;
            }
            preV = true;
            if(s==='I'){
                preD = -45;
            }else if(s==='O'){
                preD = 0;
            }else if(s==='U'){
                preD = 45;
            }else{
                console.log("Unexpected error");
                errState = -1;
            }
        }else if("ZDGBLNSTKP".includes(s)){
            // consonant
            const nextR = ("STKP".includes(s))? canvas.kipsol.radiusVoiceless: canvas.kipsol.radiusVoiced;
            const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
            const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
            const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
            area.append(nextX, nextY, nextR);
            if(!preV){
                items.push({
                    type: "line",
                    startX: cur.X,
                    startY: cur.Y,
                    endX: nextX,
                    endY: nextY
                });
            }
            items.push({
                type: s,
                centerX: nextX,
                centerY: nextY
            });
            preR = nextR;
            preV = false;
            cur.X = nextX;
            cur.Y = nextY;
        }else{
            console.log("Error: unexpected input", s);
            errState = -1;
        }
    });
    // end of word
    const nextR = canvas.kipsol.radiusEOW;
    const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
    const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
    const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
    area.append(nextX, nextY, nextR);
    if(!preV){
        items.push({
            type: "line",
            startX: cur.X,
            startY: cur.Y,
            endX: nextX,
            endY: nextY
        });
    }
    items.push({
        type: "EOW",
        centerX: nextX,
        centerY: nextY
    });
    area.append(nextX, nextY, canvas.kipsol.radiusEOW);
    //console.log(items);
    return area
}



function drawItems(canvas, itemList, offset){
    const func_map = {
        'Z': (x,y) => canvas.drawZ(x, y),
        'D': (x,y) => canvas.drawD(x, y),
        'G': (x,y) => canvas.drawG(x, y),
        'B': (x,y) => canvas.drawB(x, y),
        'L': (x,y) => canvas.drawL(x, y),
        'N': (x,y) => canvas.drawN(x, y),
        'S': (x,y) => canvas.drawS(x, y),
        'T': (x,y) => canvas.drawT(x, y),
        'K': (x,y) => canvas.drawK(x, y),
        'P': (x,y) => canvas.drawP(x, y),
    }
    let elems = [];
    itemList.forEach((item)=>{
        if(item.type==="consonant"){
            elems = elems.concat(func_map[item.str](item.centerX + offset.X, item.centerY + offset.Y));
        }else if(item.type==="EOW"){
            elems = elems.concat(canvas.drawEOW(item.centerX + offset.X, item.centerY + offset.Y));
        }else if(item.type==="line"){
            elems.push(canvas.strokeLine(item.startX + offset.X, item.startY + offset.Y, item.endX + offset.X, item.endY + offset.Y));
        }
    });
    return elems
}

function drawText(canvas, str, startX=0, startY=0){
    const func_map = {
        'Z': (x,y) => canvas.drawZ(x, y),
        'D': (x,y) => canvas.drawD(x, y),
        'G': (x,y) => canvas.drawG(x, y),
        'B': (x,y) => canvas.drawB(x, y),
        'L': (x,y) => canvas.drawL(x, y),
        'N': (x,y) => canvas.drawN(x, y),
        'S': (x,y) => canvas.drawS(x, y),
        'T': (x,y) => canvas.drawT(x, y),
        'K': (x,y) => canvas.drawK(x, y),
        'P': (x,y) => canvas.drawP(x, y),
    }
    let cur = {
        X: startX,
        Y: startY
    };
    let preR = null, preD = 0, preV = null;
    let elems = [];
    Array.from(str).forEach((s)=>{
        s = s.toUpperCase();
        if("IOU".includes(s)){
            // vowel
            if(preV==null){
                console.log("Error: unexpected input (initial vowel)");
            }
            preV = true;
            if(s==='I'){
                preD = -45;
            }else if(s==='O'){
                preD = 0;
            }else if(s==='U'){
                preD = 45;
            }else{
                console.log("Unexpected error");
            }
        }else if("ZDGBLNSTKP".includes(s)){
            // consonant
            const nextR = ("STKP".includes(s))? canvas.kipsol.radiusVoiceless: canvas.kipsol.radiusVoiced;
            const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
            const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
            const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
            elems = elems.concat(func_map[s](nextX, nextY));
            if(!preV){
                elems.push(canvas.strokeLine(cur.X, cur.Y, nextX, nextY));
            }
            preR = nextR;
            preD = 0;
            preV = false;
            cur.X = nextX;
            cur.Y = nextY;
        }else{
            console.log("Error: unexpected input", s);
        }
    });
    // end of word
    const nextR = canvas.kipsol.radiusEOW;
    const dist = (preR ?? (-nextR)) + nextR + ((!preV)? canvas.kipsol.consonantPadding: 0);
    const nextX = cur.X + dist * Math.cos(preD / 180 * Math.PI);
    const nextY = cur.Y + dist * Math.sin(preD / 180 * Math.PI);
    if(!preV){
        elems.push(canvas.strokeLine(cur.X, cur.Y, nextX, nextY));
    }
    elems = elems.concat(canvas.drawEOW(nextX, nextY));
    return elems
}

function drawTextbox(canvas, text, x, y, fontSize=20, width=null){
    const textbox = new fabric.Textbox(text, {
        top: y,
        left: x,
        fontSize: fontSize,
        width: width
    });
    canvas.add(textbox);
    return textbox;
}

const inputElement = document.getElementById('inputText');
let inputText = inputElement.value;
const canvas0 = new fabric.Canvas('canvasExample');
canvas0.kipsol = {
    consonantPadding: 10,
    radiusPivot: 3,
    radiusVoiced: 40,
    radiusVoiceless: 20,
    radiusEOW: 7
}

var textWidth = canvas0.kipsol.radiusVoiced*0.2;
var x = textWidth*2;

canvas0.setWidth(textWidth*18+canvas0.kipsol.radiusVoiced*12);
canvas0.setHeight(textWidth*6+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless*2);

drawTextbox(canvas0, "z", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "s", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
x += textWidth;
canvas0.drawZ(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
canvas0.drawS(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

drawTextbox(canvas0, "d", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "t", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
x += textWidth;
canvas0.drawD(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
canvas0.drawT(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

drawTextbox(canvas0, "g", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "k", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
x += textWidth;
canvas0.drawG(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
canvas0.drawK(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

drawTextbox(canvas0, "b", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "p", x+canvas0.kipsol.radiusVoiced-canvas0.kipsol.radiusVoiceless-textWidth, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
x += textWidth;
canvas0.drawB(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
canvas0.drawP(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

drawTextbox(canvas0, "l", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "end of word", x, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*15);
x += textWidth;
canvas0.drawL(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
canvas0.drawEOW(x + canvas0.kipsol.radiusVoiced, textWidth*4+canvas0.kipsol.radiusVoiced*2+canvas0.kipsol.radiusVoiceless);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

drawTextbox(canvas0, "n", x, textWidth, canvas0.kipsol.radiusVoiced*0.4, textWidth*2);
drawTextbox(canvas0, "end of centence", x, textWidth*3+canvas0.kipsol.radiusVoiced*2, canvas0.kipsol.radiusVoiced*0.4, textWidth*15);
x += textWidth;
canvas0.drawN(x + canvas0.kipsol.radiusVoiced, textWidth*2+canvas0.kipsol.radiusVoiced);
x += canvas0.kipsol.radiusVoiced*2 + textWidth;

const canvas = new fabric.Canvas('canvas');
canvas.setWidth(800);
canvas.setHeight(500);
canvas.kipsol = {
    consonantPadding: 10,
    radiusPivot: 3,
    radiusVoiced: 50,
    radiusVoiceless: 25,
    radiusEOW: 7,
    voweldir: {
        "I": -45,
        "O": 0,
        "U": 45
    }
}
//let area = calcTextArea(canvas, inputText);
//console.log(inputText, area);
let mergin = {
    top: 25,
    bottom: 25,
    left: 25,
    right: 25
}
let cil = calcItemList(canvas, inputText);
console.log(cil.area, cil.items);
canvas.setWidth(mergin.left + mergin.right + cil.area.maxX - cil.area.minX);
canvas.setHeight(mergin.top + mergin.bottom + cil.area.maxY - cil.area.minY);
let elems = drawItems(canvas, cil.items, {X: mergin.left-cil.area.minX, Y: mergin.top-cil.area.minY});


inputElement.addEventListener("change", (e)=>{
    elems.forEach((elem) => {canvas.remove(elem)});
    let inputText = inputElement.value;
    cil = calcItemList(canvas, inputText);
    console.log(cil.area, cil.items);
    canvas.setWidth(mergin.left + mergin.right + cil.area.maxX - cil.area.minX);
    canvas.setHeight(mergin.top + mergin.bottom + cil.area.maxY - cil.area.minY);
    elems = drawItems(canvas, cil.items, {X: mergin.left-cil.area.minX, Y: mergin.top-cil.area.minY});
});

function downloadText(fileName, text){
    const blob = new Blob([text], { type: 'text/plain' });
    const aTag = document.createElement('a');
    aTag.href = URL.createObjectURL(blob);
    aTag.target = '_blank';
    aTag.download = fileName;
    aTag.click();
    URL.revokeObjectURL(aTag.href);
}
function downloadAsSVG(){
    downloadText(`${inputElement.value}.svg`, canvas.toSVG());
}
function downloadAsJSON(){
    downloadText(`${inputElement.value}.json`, JSON.stringify(canvas));
}
    </script>
</body>
</html>